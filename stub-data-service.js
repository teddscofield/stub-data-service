var   HTTP = require("http"),
      LOG = require('winston'),
      URL = require('url'),
      _ = require('underscore');


(function(){

  var PORT_NUM = 28888,
      CONTENT_TYPE = "application/json",
      DATA = {};

  //
  // data object representing response data
  //
  var ResponseData = function(status,message) {
    this.status = status;
    this.msg = message;
  }


  //
  // data object representing request data parsed out
  // into the fields needed by the service
  //
  var ParsedRequest = function(request,chunkedData) {

    var parsedUrl = URL.parse(request.url,true),
        parts = parsedUrl.path.split('/').slice(1);

    this.requestMethod = request.method;
    this.requestData = chunkedData;
    this.resourceName = parts[0];
    this.resourceId = parts[1];

    // logic for overriding REST method in the URL
    // to allow for hitting different methods in
    // a browsers address bar.
    if (request.url.indexOf('/_REST') === 0) {
      switch(parts[0]) {
        case '_REST_POST': this.requestMethod = 'POST'; break;
        case '_REST_PUT':  this.requestMethod = 'PUT';  break;
        case '_REST_DELETE': this.requestMethod = 'DELETE'; break;
        default: throw new Exception("unrecognized method override"); break;
      }

      var workingUrl = '/'+ request.url.split('/').slice(2).join('/'),
          workingParsedUrl = URL.parse(workingUrl,false),
          workingParts = workingParsedUrl.pathname.split('/').slice(1);

      this.requestData = workingParsedUrl.query;
      this.resourceName = workingParts[0];
      this.resourceId = workingParts[1];
    }
  }

  //
  // application login for GET requests
  //
  function handle_get(parsedRequest) {

    var resourceName = parsedRequest.resourceName, 
        resourceId = parsedRequest.resourceId; 

    // no data for the resource name is a 404
    if (!DATA[resourceName]) {
      return new ResponseData(404,"did not find resource: "+resourceName);
    }

    // resource Id specified but no data for that id
    // stored is a 404
    if (resourceId && !DATA[resourceName][resourceId]) {
      return new ResponseData(404,"no data found for "+resourceName+" "+resourceId);
    }

    // return data for the specified id
    if (resourceId) {
      return new ResponseData(200,JSON.stringify(DATA[resourceName][resourceId]));
    }

    // return all data for the resource
    return new ResponseData(200,JSON.stringify(DATA[resourceName]));
  };



  //
  // application logic for POST requests
  //
  function handle_post(parsedRequest) {
    // requests w/o an id specified are considered
    // create requests. requests w/ an id are
    // considered update requests.

    var data = parsedRequest.requestData;
    var resourceName = parsedRequest.resourceName, 
        resourceId = parsedRequest.resourceId; 
        rcd = null,
        parsedData = URL.parse("?"+data,true);

    // create a new resource slot if none exists
    if (!DATA[resourceName]) {
      DATA[resourceName] = {};
    }

    // no request id specified, this is a create, generate new ID
    if (!resourceId) {
      resourceId = find_next_autogen_key(resourceName, 1);
    }

    // create an empty object if one doesn't exist
    if (!DATA[resourceName][resourceId]) {
      DATA[resourceName][resourceId] = {};
    }

    // TODO: logic to enforce POST's w/ id's as updates
    // only.  The above switch makes them creates too when
    // POST's should 404 if the resourceId doesn't exist

    LOG.debug('updating '+resourceName+' '+resourceId);
    
    // use underscore's extend method to update/overwrite the
    // object in the data store.
    rcd = _.extend(DATA[resourceName][resourceId],{id:resourceId},parsedData.query);
    DATA[resourceName][resourceId] = rcd;

    // TODO: write data record to the file system.

    return new ResponseData(201,JSON.stringify(rcd));
  };

  // helper function to get the next autogenerated key
  function find_next_autogen_key(resourceName,offset) {
    var nextId = 'id_'+(Object.keys(DATA[resourceName]).length + offset);
    if (DATA[resourceName][nextId]) {
      nextId = find_next_autogen_key(resourceName,offset + 1);
    }
    return nextId;
  }

  //
  // application logic for PUT requests
  //
  function handle_put(parsedRequest,data) {
    // TODO: enforce put vs post rules, for now
    // they can both do the same
    return handle_post(parsedRequest,data);
  };


  //
  // application logic for DELETE requests
  // 
  function handle_delete(parsedRequest) {
    var resourceName = parsedRequest.resourceName, 
        resourceId = parsedRequest.resourceId; 

    // no data for the resource name is a 404
    if (!DATA[resourceName]) {
      return new ResponseData(404,"did not find resource: "+resourceName);
    };

    // resource Id specified but no data for that id
    // stored is a 404
    if (resourceId && !DATA[resourceName][resourceId]) {
      return new ResponseData(404,"no data found for "+resourceName+" "+resourceId);
    };

    delete DATA[resourceName][resourceId];

    return new ResponseData(200,"Successfully deleted "+resourceName+" "+resourceId);
    // TODO: figure out the best way to send a status response w/o a response body.
  };

  //
  // application logic for requests to this server
  //
  function server_request_handler(request,response) {
    LOG.debug(new Date().getTime()+": "+request.method+" "+request.url);

    // load all request data into a single variable
    var chunkedData = '';
    request.on('data', function (chunk) {
      LOG.debug('data chunk: '+chunk);
      chunkedData += chunk;
    });

    // attach to the 'end' event to handle the request
    request.on('end',function() {
      var parsedRequest = new ParsedRequest(request,chunkedData),
          method = parsedRequest.requestMethod,
          msg = "",
          statusCode = 200,
          res = {};

      switch (method) {
        case 'GET'    : res = handle_get(parsedRequest); break;
        case 'POST'   : res = handle_post(parsedRequest); break;
        case 'PUT'    : res = handle_put(parsedRequest); break;
        case 'DELETE' : res = handle_delete(parsedRequest); break;
        default:
          res.msg = 'Unsupported request type: '+method;
          res.status = 501;
        break;
      };

      // write the response to the client
      response.writeHead(res.status, {"Content-Type": CONTENT_TYPE });
      response.write(res.msg);
      response.end();
    })
  };

  //
  // main server loop
  //
  HTTP.createServer(function(request, response) {
    server_request_handler(request, response);
  }).listen(PORT_NUM);
  LOG.info('started server on port '+PORT_NUM);

})();

/*
200 OK - contains entity in response body
201 Created - contains entity in response body
204 No Content - no response body
400 Bad Request - response body may contain details regarding the validation error
404 Not Found - response body may contain details regarding the record that coudl not be found
*/