var   HTTP = require("http"),
      LOG = require('winston'),
      URL = require('url'),
      _ = require('underscore');


(function(){

  var PORT_NUM = 28888,
      CONTENT_TYPE = "application/json",
      DATA = {};

  //
  // data object representing response data
  //
  var ResponseData = function(status,message) {
    this.status = status;
    this.msg = message;
  }


  //
  // data object representing request data parsed out
  // into the fields needed by the service
  //
  var ParsedRequest = function(request,chunkedData) {

    var parsedUrl = URL.parse(request.url,true),
        parts = parsedUrl.path.split('/').slice(1);

    this.requestMethod = request.method;
    this.requestData = chunkedData;
    this.resourceName = parts[0];
    this.resourceId = parts[1];

    // logic for overriding REST method in the URL
    // to allow for hitting different methods in
    // a browsers address bar.
    if (request.url.indexOf('/_REST') === 0) {
      switch(parts[0]) {
        case '_REST_POST': this.requestMethod = 'POST'; break;
        case '_REST_PUT':  this.requestMethod = 'PUT';  break;
        case '_REST_DELETE': this.requestMethod = 'DELETE'; break;
        default: throw new Exception("unrecognized method override"); break;
      }

      var workingUrl = '/'+ request.url.split('/').slice(2).join('/'),
          workingParsedUrl = URL.parse(workingUrl,false),
          workingParts = workingParsedUrl.pathname.split('/').slice(1);

      this.requestData = workingParsedUrl.query;
      this.resourceName = workingParts[0];
      this.resourceId = workingParts[1];
    }
  }

  //
  // application login for GET requests
  //
  function handle_get(parsedRequest) {

    var resourceName = parsedRequest.resourceName, 
        resourceId = parsedRequest.resourceId; 

    // no data for the resource name is a 404
    if (!DATA[resourceName]) {
      return new ResponseData(404,"did not find resource: "+resourceName);
    }

    // resource Id specified but no data for that id
    // stored is a 404
    if (resourceId && !DATA[resourceName][resourceId]) {
      return new ResponseData(404,"no data found for "+resourceName+" "+resourceId);
    }

    // return data for the specified id
    if (resourceId) {
      return new ResponseData(200,JSON.stringify(DATA[resourceName][resourceId]));
    }

    // return all data for the resource
    return new ResponseData(200,JSON.stringify(DATA[resourceName]));
  };



  //
  // application logic for POST requests
  //
  function handle_post(parsedRequest) {
    // requests w/o an id specified are considered
    // create requests. requests w/ an id are
    // considered update requests.

    var data = parsedRequest.requestData;
    var resourceName = parsedRequest.resourceName, 
        resourceId = parsedRequest.resourceId; 
        rcd = null,
        parsedData = URL.parse("?"+data,true);

    // create a new resource slot if none exists
    if (!DATA[resourceName]) {
      DATA[resourceName] = {};
    }

    // no request id specified, this is a create, generate new ID
    if (!resourceId) {
      resourceId = find_next_autogen_key(resourceName, 1);
    }

    // create an empty object if one doesn't exist
    if (!DATA[resourceName][resourceId]) {
      DATA[resourceName][resourceId] = {};
    }

    // TODO: logic to enforce POST's w/ id's as updates
    // only.  The above switch makes them creates too when
    // POST's should 404 if the resourceId doesn't exist

    LOG.debug('updating '+resourceName+' '+resourceId);
    
    // use underscore's extend method to update/overwrite the
    // object in the data store.
    rcd = _.extend(DATA[resourceName][resourceId],{id:resourceId},parsedData.query);
    DATA[resourceName][resourceId] = rcd;

    // TODO: write data record to the file system.

    return new ResponseData(201,JSON.stringify(rcd));
  };

  // helper function to get the next autogenerated key
  function find_next_autogen_key(resourceName,offset) {
    var nextId = 'id_'+(Object.keys(DATA[resourceName]).length + offset);
    if (DATA[resourceName][nextId]) {
      nextId = find_next_autogen_key(resourceName,offset + 1);
    }
    return nextId;
  }

  //
  // application logic for PUT requests
  //
  function handle_put(parsedRequest,data) {
    // TODO: enforce put vs post rules, for now
    // they can both do the same
    return handle_post(parsedRequest,data);
  };


  //
  // application logic for DELETE requests
  // 
  function handle_delete(parsedRequest) {
    var resourceName = parsedRequest.resourceName, 
        resourceId = parsedRequest.resourceId; 

    // no data for the resource name is a 404
    if (!DATA[resourceName]) {
      return new ResponseData(404,"did not find resource: "+resourceName);
    };

    // resource Id specified but no data for that id
    // stored is a 404
    if (resourceId && !DATA[resourceName][resourceId]) {
      return new ResponseData(404,"no data found for "+resourceName+" "+resourceId);
    };

    delete DATA[resourceName][resourceId];

    return new ResponseData(200,"Successfully deleted "+resourceName+" "+resourceId);
    // TODO: figure out the best way to send a status response w/o a response body.
  };

  //
  // application logic for requests to this server
  //
  function server_request_handler(request,response) {
    LOG.debug(new Date().getTime()+": "+request.method+" "+request.url);

    // load all request data into a single variable
    var chunkedData = '';
    request.on('data', function (chunk) {
      LOG.debug('data chunk: '+chunk);
      chunkedData += chunk;
    });

    // attach to the 'end' event to handle the request
    request.on('end',function() {
      var parsedRequest = new ParsedRequest(request,chunkedData),
          method = parsedRequest.requestMethod,
          msg = "",
          statusCode = 200,
          res = {};

      switch (method) {
        case 'GET'    : res = handle_get(parsedRequest); break;
        case 'POST'   : res = handle_post(parsedRequest); break;
        case 'PUT'    : res = handle_put(parsedRequest); break;
        case 'DELETE' : res = handle_delete(parsedRequest); break;
        default:
          res.msg = 'Unsupported request type: '+method;
          res.status = 501;
        break;
      };

      // write the response to the client
      response.writeHead(res.status, {"Content-Type": CONTENT_TYPE });
      response.write(res.msg);
      response.end();
    })
  };

  //
  // main server loop
  //
  HTTP.createServer(function(request, response) {
    server_request_handler(request, response);
  }).listen(PORT_NUM);
  LOG.info('started server on port '+PORT_NUM);

})();


/*

Overview
========
A simple REST service intended to be used as a service
stub during the early stages of the development, design or
discovery phases of a project.

The rationale here is that I often want a service that
will easily persist or return data for me while I'm
playing around with front-end interfaces and code.  I

It doesn't matter that it is not necessarily the way I 
want my back-end service to look ultimately but rather 
that it just holds on to and returns data.  I'm OK with
hitting a generic REST URL structure at first while I'm 
playing with an idea.

Another thing I wanted to have is the ability to hit
POST, PUT and DELETE from a browser's address bar. So
this service will have an optional path prefix that
will tell it to treat a GET request differently.


Features
========
  - responds to ANY http request
    * with what though (besides a 200)?
  - supports GET, POST, PUT, DELETE methods
  - TODO: support JSONP
  - persists abitrary key=value pairs as javascript objects.
    * in memory for now
    * TODO: I plan to persist to disk once the service is up and running 
  - optional GET syntax to access POST, PUT, DELETE methods for convenience (i.e. 
    allows using the browser address bar)



API documentation
=================
- all inputs expected to be key=value pairs
- general URL syntax:
/{_REST_COMMAND}/resource_name/:id?key1=value1&key2=value2&key3=value3

  * {_REST_COMMAND}
    Optional request type override. Treat request with the specified HTTP verb:
    * _REST_POST - treat request as a POST, query params treated as POST data
    * _REST_PUT - treat request as a PUT, query params treated as PUT data
    * _REST_DELETE - treate request as a DELETE

    This if for experimental development only (i.e. just trying things out)!

  * resource_name
    The type of object being accessed

  * :id
    The record id of a specific object

  * key=value&key2=value2
    Object data.  When the optional request type override is being used, the
    service will treat the GET parameters as request data



Methods:
  - GET /resource_name

    response:
    200 - return all records of the specified resource type
    404 - if the specified resource type does not exist (e.g. 
          hasn't been created yet).

    TODO: range and/or set parameters

  - GET /resource_name/:id

    response:    
    200 - return a single record of the specified resource type
    404 - if no record for the specified id was found

  - POST /resource
    PUT /resource
    create a new recoud of the type specified by resource

    response:
    201 - created new record (w/ JSON representation of the object)
    400 - validation error (w/ message WRT the error)

  - PUT /resource/:id
    create new or overwrite existing resource record

    response:
    201 - new record created (w/ JSON representation of the object)
    200 - existing record overwritten w/ JSON representation of the new version of the object
    400 - validation error (w/ message WRT the error)


  - POST /resource/:id
    update an existing resource record 

    response:
    200 - successful update
          (return entire object? or just the updated data? copy of the old data?)
    404 - record for specified id not found
    400 - validation error (w/ message WRT the error)

  - DELETE /resource/:id
    delete the specified resource record

    response:
    204 - record deleted sucessfully (w/ no message body in response)
    404 - specified resource record not found


200 OK - contains entity in response body
201 Created - contains entity in response body
204 No Content - no response body
400 Bad Request - response body may contain details regarding the validation error
404 Not Found - response body may contain details regarding the record that coudl not be found
*/